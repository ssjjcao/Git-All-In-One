import git
import re
import os
from lxml import etree


def get_file_changed(repo, sha1):
    changed_files = set()
    commit = repo.commit(sha1)
    parent = repo.commit(sha1 + '~')
    renamed_file = []
    for x in parent.diff(commit):
        if x.change_type == 'R':  # Renamed
            assert x.a_path != x.b_path
            renamed_file.append([x.a_path, x.b_path])
            continue

        assert x.a_path == x.b_path and x.change_type in ("A", "D", "M", "T")
        if x.a_path is not None:
            changed_files.add(x.a_path)
        if x.b_path is not None:
            changed_files.add(x.b_path)
    return list(changed_files), renamed_file


def _get_diff_line_num(diff):
    lines = diff.split("\n")
    at_index = len(lines)
    for i in range(len(lines)):
        if lines[i].startswith("@@ -"):
            assert i <= 7
            at_index = i
            break
    lines = lines[at_index:]

    parent_modify_lines = []
    this_modify_lines = []
    parent_line = 0
    this_line = 0
    line_pattern = r"@@ -(\d+)(,\d+)? \+(\d+)(,\d+)? @@"
    for line in lines:
        if line.startswith("@@ -"):
            result = re.search(line_pattern, line)
            parent_line = int(result.group(1)) - 1
            this_line = int(result.group(3)) - 1
        elif line.startswith("+"):
            this_line += 1
            this_modify_lines.append(this_line)
        elif line.startswith("-"):
            parent_line += 1
            parent_modify_lines.append(parent_line)
        else:
            parent_line += 1
            this_line += 1
    return parent_modify_lines, this_modify_lines


def _get_function_line_scope(repo, sha1, file_name):
    function_line_scope = dict()
    try:
        file_content = repo.git.show(sha1 + ":" + file_name)
    except:  # file not in sha1
        print("Warning:", sha1, file_name, "not exist?!")
        return function_line_scope
    tmp_file_name = "%s_%s" % (sha1, file_name.replace("/", "_"))
    tmp_file_name = tmp_file_name.lower()
    with open(tmp_file_name, mode='w', encoding='utf-8', errors='ignore') as f:
        f.write(file_content)

    srcml_output = os.popen("srcml --position %s" % tmp_file_name)
    srcml_output = srcml_output.read()
    os.remove(tmp_file_name)

    root = etree.fromstring(srcml_output.encode('utf-8'))

    # end position of function definition generated by srcml may be wrong
    # some mistakes have been work around (i.e., partially corrected) in this script
    # e.g., do_tls_setsockopt_conf in https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/tls/tls_main.c?id=95fa145479fbc0a0c1fd3274ceb42ec03c042a4a
    # More references
    # https://github.com/srcML/srcML/issues/1697
    # https://github.com/srcML/srcML/issues/1700

    # function definition may also be omitted by srcml, i.e., incorrectly identified as macro
    # Oops... hard to deal with it
    # e.g., horrible_cidr_to_mask, init_peer are identified as macro in https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/wireguard/selftest/allowedips.c?id=e7096c131e5161fa3b8e52a650d7719d2857adfd

    last_func_name = None
    for func in root.xpath("//*[local-name() = 'function']"):
        func_name = func.xpath("./*[local-name() = 'name']/text()")[0]
        # POS_NS = 'http://www.srcML.org/srcML/position'
        # start = func.attrib[f'{{{POS_NS}}}start']
        # end = func.attrib[f'{{{POS_NS}}}end']
        start = func.xpath("./@*[local-name() = 'start']")[0]
        start_line_num = int(start.split(":")[0])
        end = func.xpath("./@*[local-name() = 'end']")[0]
        end_line_num = int(end.split(":")[0])

        block_content_end = func.xpath(
            "./*[local-name() = 'block']/*[local-name() = 'block_content']/@*[local-name() = 'end']")
        if block_content_end:
            end_line_num_by_block_content = int(block_content_end[0].split(":")[0]) + 1
            if end_line_num_by_block_content < end_line_num:
                end_line_num = end_line_num_by_block_content
                # print(func_name)
        else:
            block_end = func.xpath("./*[local-name() = 'block']/@*[local-name() = 'end']")
            if block_end:
                block_end_col = int(block_end[0].split(":")[1])
                if block_end_col == 0:
                    # block content is empty (without start and end) && block end col is 0 (incorrect indeed)
                    # => function end line num = block start line num
                    # FIXME: maybe it's better to determine the function range by locating the line num of "}"
                    block_start_line_num = \
                        func.xpath("./*[local-name() = 'block']/@*[local-name() = 'start']")[0].split(":")[0]
                    end_line_num_by_block = int(block_start_line_num)
                    if end_line_num_by_block < end_line_num:
                        end_line_num = end_line_num_by_block

        if last_func_name is not None:
            if function_line_scope[last_func_name][-1][1] > start_line_num:
                function_line_scope[last_func_name][-1][1] = start_line_num - 1
                # print(sha1, file_name, last_func_name, "->", function_line_scope[last_func_name][-1][1])

        if func_name not in function_line_scope:
            function_line_scope[func_name] = [[start_line_num, end_line_num]]
        else:
            function_line_scope[func_name].append([start_line_num, end_line_num])

        last_func_name = func_name
    return function_line_scope


def _get_function_changed_info(function_line_scope, line_changed):
    """
    :param function_line_scope: { function: [[start, end], ...] }
    :param line_changed: [line, ...]
    :return: { function: [line, ...] }
    """
    function_changed_info = dict()
    for line in line_changed:
        found_flag = False
        for func_name, scope_list in function_line_scope.items():
            for scope in scope_list:
                if scope[0] <= line <= scope[1]:
                    if func_name in function_changed_info:
                        function_changed_info[func_name].append(line)
                    else:
                        function_changed_info[func_name] = [line]
                    found_flag = True
            if found_flag:
                break
    return function_changed_info


def get_function_changed(repo, sha1, language="C/C++"):
    """
    :param sha1: only support non-initial commit, otherwise exception will be thrown
    """
    if language != "C/C++":
        return "Language %s NOT Supported" % language

    src_suffix = {"C/C++": ('.c', '.cpp', '.cc', '.cxx', '.cp', '.C', '.CC', '.c++', '.C++', '.hpp', '.h', '.hh')}

    changed_files, renamed_files = get_file_changed(repo, sha1)
    changed_functions = set()
    for file in changed_files:
        if any(file.endswith(x) for x in src_suffix[language]):
            parent_modify_lines, this_modify_lines = _get_diff_line_num(repo.git.diff(sha1 + '~', sha1, '--', file))
            if parent_modify_lines:
                parent_sha1 = repo.commit(sha1 + "~").hexsha
                parent_function_scope = _get_function_line_scope(repo, parent_sha1, file)
                parent_function_changed_info = _get_function_changed_info(parent_function_scope, parent_modify_lines)
                for func in parent_function_changed_info.keys():
                    changed_functions.add(func)

            if this_modify_lines:
                this_function_scope = _get_function_line_scope(repo, sha1, file)
                this_function_changed_info = _get_function_changed_info(this_function_scope, this_modify_lines)
                for func in this_function_changed_info.keys():
                    changed_functions.add(func)

    for [a_path, b_path] in renamed_files:
        if any(a_path.endswith(x) for x in src_suffix[language]) and \
                any(b_path.endswith(x) for x in src_suffix[language]):
            start_flag = "diff --git a/%s b/%s" % (a_path, b_path)
            all_diff_lines = repo.git.diff(sha1 + '~', sha1).split("\n")
            start_index = None
            end_index = None
            for i in range(len(all_diff_lines)):
                if start_index is not None and all_diff_lines[i].startswith("diff --git a"):
                    end_index = i
                    break
                elif start_flag == all_diff_lines[i]:
                    start_index = i

            assert start_index is not None

            if end_index:
                rename_related_diff_lines = all_diff_lines[start_index: end_index]
            else:
                rename_related_diff_lines = all_diff_lines[start_index:]

            rename_related_diff = ""
            for line in rename_related_diff_lines:
                rename_related_diff += line + "\n"

            parent_modify_lines, this_modify_lines = _get_diff_line_num(rename_related_diff)
            if parent_modify_lines:
                parent_sha1 = repo.commit(sha1 + "~").hexsha
                parent_function_scope = _get_function_line_scope(repo, parent_sha1, a_path)
                parent_function_changed_info = _get_function_changed_info(parent_function_scope, parent_modify_lines)
                for func in parent_function_changed_info.keys():
                    changed_functions.add(func)

            if this_modify_lines:
                this_function_scope = _get_function_line_scope(repo, sha1, b_path)
                this_function_changed_info = _get_function_changed_info(this_function_scope, this_modify_lines)
                for func in this_function_changed_info.keys():
                    changed_functions.add(func)

    return changed_functions


if __name__ == "__main__":
    test_repo = git.Repo("/home/ssjjcao/linux")
    print(get_function_changed(test_repo, "32857cf57f920cdc03b5095f08febec94cf9c36b"))

    print(get_file_changed(test_repo, "32857cf57f920cdc03b5095f08febec94cf9c36b"))

    a, b = _get_diff_line_num(test_repo.git.diff('32857cf57f920cdc03b5095f08febec94cf9c36b~',
                                                 "32857cf57f920cdc03b5095f08febec94cf9c36b",
                                                 '--', "net/tls/tls_main.c"))
    c = _get_function_line_scope(git.Repo("/home/ssjjcao/linux"),
                                 "32857cf57f920cdc03b5095f08febec94cf9c36b",
                                 "net/tls/tls_main.c")
    for f, s in c.items():
        print(f, s)
